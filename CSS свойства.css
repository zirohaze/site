 width:50px; /* ширина */
    height:50px; /* высота */
    background-color:red; /* цвет фона */
    margin: 10px; /* отступ от других элементов */

Список доступных псевдоклассов:

    :root: позволяет выбрать корневой элемент веб-страницы, наверное наименее полезный селектор, так как на правильной веб-странице корневым элементом практически всегда является элемент <html>

    :link: применяется к ссылкам и представляет ссылку в обычном состоянии, по которой еще не совершен переход

    :visited: применяется к ссылкам и представляет ссылку, по которой пользователь уже переходил

    :active: применяется к ссылкам и представляет ссылку в тот момент, когда пользователь осуществляет по ней переход

    :hover: представляет элемент, на который пользователь навел указатель мыши. Применяется преимущественно к ссылкам, однако может также применяться и к другим элементам, например, к параграфам

    :focus: представляет элемент, который получает фокус, то есть когда пользователь нажимает клавишу табуляции или нажимает кнопкой мыши на поле ввода (например, текстовое поле)

    :not: позволяет исключить элементы из списка элементов, к которым применяется стиль

    :lang: стилизует элементы на основании значения атрибута lang

    :empty: выбирает элементы, которые не имеют вложенных элементов, то есть являются пустыми

Особую группу псевдоклассов образуют псевдоклассы, которые позволяют выбрать определенные дочерние элементы:

    :first-child: представляет элемент, который является первым дочерним элементом

    :last-child: представляет элемент, который является последним дочерним элементом

    :only-child: представляет элемент, который является единственным дочерним элементом в каком-нибудь контейнере

    :only-of-type: выбирает элемент, который является единственным элементом определенного типа (тега) в каком-нибудь контейнере

    :nth-child(n): представляет дочерний элемент, который имеет определенный номер n, например, второй дочерний элемент

    :nth-last-child(n): представляет дочерний элемент, который имеет определенный номер n, начиная с конца

    :nth-of-type(n): выбирает дочерний элемент определенного типа, который имеет определенный номер

    :nth-last-of-type(n): выбирает дочерний элемент определенного типа, который имеет определенный номер, начиная с конца


Ряд псевдоклассов используется для работы с элементами форм:

    :enabled: выбирает элемент, если он доступен для выбора (то есть у него не установлен атрибут disabled)

    :disabled: выбирает элемент, если он не доступен для выбора (то есть у него установлен атрибут disabled)

    :checked: выбирает элемент, если у него установлен атрибут checked (для флажков и радиокнопок)

    :default: выбирает элементы по умолчанию

    :valid: выбирает элемент, если его значение проходит валидацию HTML5

    :invalid: выбирает элемент, если его значение не проходит валидацию

    :in-range: выбирает элемент, если его значение находится в определенном диапазоне (для элементов типа ползунка)

    :out-of-range: выбирает элемент, если его значение не находится в определенном диапазоне

    :required: выбирает элемент, если у него установлен атрибут required

    :optional: выбирает элемент, если у него не установлен атрибут required




Псевдоэлементы обладают рядом дополнительных возможностей по выбору элементов веб-страницы и похожи на псевдоклассы. Список доступных псевдоэлементов:

    ::first-letter: позволяет выбрать первую букву из текста

    ::first-line: стилизует первую строку текста

    ::before: добавляет сообщение до определенного элемента

    ::after: добавляет сообщение после определенного элемента

    ::selection: выбирает выбранные пользователем элементы





Например символ ^ позволяет выбрать все атрибуты, которые начинаются на определенный текст. 

Если значение атрибута должно иметь в конце определенный текст, то для проверки используется символ $. Например, нам надо выбрать все изображения в формате jpg. В этом случае мы можем проверить, оканчивается ли значение атрибута src на текст ".jpg"

И еще один символ "*" (звездочка) позволяет выбрать все элементы с атрибутами, которые в своем значении имеют определенный текст (не важно где - в начале, середине или конце)




Псевдокласс :is() применяется для сокращения длинных селекторов. Функция псевдокласса :is() принимает список селекторов для выбора элементов html.
Псевдокласс :where() работает подобно :is(), он также принимает набор селекторов и выбирает все соответстующие селекторы
разница между :is() и :where()? Псевдокласс :is() применяет каскадность стилей (selector specificity), которая определяется по селектору с самым большим рангом. А для стилей псевдокласса :where() ранг селекторов всегда равен 0.



за установку цвета текста отвечает свойство color, за установку фона элемента - свойство background-color, а за установку цвета границы - border-color.

прозрачность элементов - свойство opacity.


Свойство font-family устанавливает семейство шрифтов, которое будет использоваться. 


Свойство font-weight задает толщину шрифта. Оно может принимать 9 числовых значений: 100, 200, 300, 400,...900. 100 - очень тонкий шрифт, 900 - очень плотный шрифт.

В реальности чаще для этого свойства используют два значения: normal (нежирный обычный текст) и bold (полужирный шрифт):


Свойство font-style позволяет выделить текст курсивом. Для этого используется значение italic,Если надо отменить курсив, то применяется значение normal


Если использовать не стандарный шрифт Свойство font-family задает название шрифта, а свойство src - путь к шрифту.Как правило, для хранения своих шрифтов рядом с веб-страницей создается папка fonts.После подключения шрифта, его можно использовать в стилях


Чтобы браузер мог автоматически распознавать разные варианты шрифта, к директиве @font-face добавляются свойства font-weight и font-style, которые соответственно устанавливают выделение жирным и выделение курсивом



Для установки размера шрифта используется свойство font-size:px
В CSS имеется семь ключевых слов, которые позволяют назначить размер шрифта относительно базового:

    medium: базовый размер шрифта браузера (16 пикселей)

    small: 13 пикселей

    x-small: 10 пикселей

    xx-small: 9 пикселей

    large: 18 пикселей

    x-large: 24 пикселя

    xx-large: 32 пикселя
Проценты позволяют задать значение относительно базового или унаследованного шрифта:150%.В данном случае высота шрифта будет составлять 150% от базового, то есть 16px * 1,5 = 24px


Свойство text-transform изменяет регистр текста. Оно может принимать следующие значения:

    capitalize: делает первую букву слова заглавной

    uppercase: все слово переводится в верхний регистр

    lowercase: все слово переводится в нижний регистр

    none: регистр символов слова никак не изменяется

Свойство text-decoration позволяет добавить к тексту некоторые дополнительные эффекты. Это свойство может принимать следующие значения:

    underline: подчеркивает текст

    overline: надчеркивает текст, проводит верхнюю линию

    line-through: зачеркивает текст

    none: к тексту не применяется декорирование


Два свойства CSS позволяют управлять интервалом между символами и словами текста. Для межсимвольного интервала применяется атрибут letter-spacing, а для интервала между словами - word-spacing:px




С помощью свойства text-shadow можно создать тени для текста. Для этого свойства необходимо задать четыре значения: горизонтальное смещение тени относительно текста, вертикальное смещение тени относительно текста, степень размытости тени и цвет отбрасываемой тени. Например  
text-shadow: 5px 4px 3px #999;


Свойство line-height определяет межстрочный интервал. Для его установки можно использовать пиксели, проценты или единицы em. Как правило, применяются либо проценты, либо em.


Свойство text-align выравнивает текст относительно одной из сторон веб-страницы. Оно принимает следующие значения:

    left: текст выравнивается по левой стороне

    right: текст выравнивается по правой стороне

    justify: выравнивание по ширине, слова равномерно распределяются по строке

    center: выравнивание по центру


Свойство text-indent задает отступ первой строки абзаца. Для установки отступа могут применяться стандартные единицы измерения, например, em или пиксели



CSS предоставляет специальные свойства по стилизации списков. Одним из таких свойств является list-style-type. Оно может принимать следующие значения для нумерованных списков:

    decimal: десятичные числа, отсчет идет от 1

    decimal-leading-zero: десятичные числа, которые предваряются нулем, например, 01, 02, 03, … 98, 99

    lower-roman: строчные латинские цифры, например, i, ii, iii, iv, v

    upper-roman: заглавные латинские цифры, например, I, II, III, IV, V…

    lower-alpha: строчные латинские буквы, например, a, b, c..., z

    upper-alpha: заглавные латинские буквы, например, A, B, C, … Z

Для ненумерованных списков:

    disc: черный диск

    circle: пустой кружочек

    square: черный квадратик



Веб-браузеры обычно отображают маркеры списка слева от элементов списка. С помощью свойства list-style-position мы можем настроить их позиционирование. Это свойство принимает два значения: outside (по умолчанию) и inside (обеспечивает равномерное распределение по ширине


Свойство list-style-image позволяет задать в качестве маркера изображение Свойство list-style-image в качестве значения принимает путь к изображению url(phone_touch.png), где "phone_touch.png" - это название файла изображения. То есть в данном случае предполагается, что в одной папке с веб-страницей находится файл изображения phone_touch.png.




CSS предоставляет ряд свойств, которые помогают стилизовать таблицу:

border-collapse: устанавливает, как будет стилизоваться граница смежных ячеек

border-spacing: устанавливает промежутки между границами смежных ячеек

caption-side: устанавливает положение элемента caption

empty-cells: задает режим отрисовки для пустых ячеек

table-layout: определяет размеры таблицы


При установке границ между столбцами с помощью свойства border-collapse можно установить общую или раздельную границу между смежными ячейками:

    collapse: смежные ячейки имеют общую границу

    separate: смежные ячейки имеют отдельные границы, которые разделяются пространством

Если смежные ячейки имеют раздельные границы, то с помощью свойства border-spacing можно установить пространство между границами


Свойство empty-cells позволяет стилизовать пустые ячейки с помощью одного из следующих значений:

    show: пустые ячейки отображаются, значение по умолчанию

    hide: пустые ячейки не отображаются


Свойство caption-side управляет позицией заголовка и может принимать следующие значения:

    top: позиционирование заголовка вверху (значение по умолчанию)

    bottom: позиционирование заголовка внизу


С помощью свойства table-layout можно управлять размером таблицы. По умолчанию это свойство имеет значение auto, при котором браузер устанавливает ширину столбцов таблицы автоматически, исходя из ширины самой широкой ячейки в столбце. А из ширины отдельных столбцов складывается ширина всей таблицы.

Однако с помощью другого значения - fixed можно установить фиксированную ширину:
table {
    border: 1px solid #ccc;
    border-spacing: 3px;
    table-layout: fixed;
    width:350px; 
}




Как правило, содержимое ячеек таблицы выравнивается по центру ячейки. Но с помощью свойства vertical-align это поведение можно переопределить. Это свойство принимает следующие значения:

    top: выравнивание содержимого по верху ячейки

    baseline: выравнивание первой строки текста по верху ячейки

    middle: выравнивание по центру (значение по умолчанию)

    bottom: выравнивание по низу

Свойство vertical-align применяется только к элементам <th> и <td>:


Свойство margin определяет отступ элемента от других элементов или границы внешнего контейнера. Существуют специальные свойства CSS для задания отступов для каждой стороны:

    margin-top: отступ сверху

    margin-bottom: отступ снизу

    margin-left: отступ слева

    margin-right: отступ справа



Свойство padding задает внутренние отступы от границы элемента до его внутреннего содержимого. Как и для свойство margin, в CSS имеются четыре свойства, которые устанавливают отступы для каждой из сторон:

    padding-top: отступ сверху

    padding-bottom: отступ снизу

    padding-left: отступ слева

    padding-right: отступ справа


Граница отделяется элемент от внешнего по отношению к нему содержимого. При этом граница является частью элемента.

Для настройки границы могут использоваться сразу несколько свойств:

    border-width: устанавливает ширину границы

    border-style: задает стиль линии границы

    border-color: устанавливает цвет границы

Свойство border-width может принимать следующие типы значений:

    Значения в единицах измерения, таких как em, px или cm
Одно из константных значений: thin (тонкая граница - 1px), medium (средняя по ширине - 3px), thick (толстая - 5px)



Свойство border-style оформляет тип линии границы и может принимать одно из следующих значений:

    none: граница отсутствует

    solid: граница в виде обычной линии

    dashed: штриховая линия

    dotted: линия в виде последовательности точек

    double: граница в виде двух параллельных линий

    groove: граница имеет трехмерный эффект

    inset: граница как бы вдавливается во внутрь

    outset: аналогично inset, только граница как бы выступает наружу

    ridge: граница также реализует трехмерный эффект



Вместо установки по отдельности цвета, стиля и ширины границы мы можем использовать одно свойство - border:
1
	
border: ширина стиль цвет

Например:
1
	
border: 2px solid red;

Для установки границы для отдельных сторон можно использовать одно из свойств:
1
2
3
4
	
border-top
border-bottom
border-left
border-right

Их использование аналогично:
1
	
border-top: 2px solid red;




Свойство border-radius позволяет округлить границу. Это свойство принимает значение радиуса в пикселях или единицах em.

Так как у элемента может быть максимально четыре угла, то мы можем указать четыре значения для установки радиуса у каждого углов



Размеры элементов задаются с помощью свойств width (ширина) и height (высота).

Значение по умолчанию для этих свойств - auto, то есть браузер сам определяет ширину и высоту элемента. Можно также явно задать размеры с помощью единиц измерения (пикселей, em) или с помощью процентов

С помощью дополнительного набора свойств можно установить минимальные и максимальные размеры:

    min-width: минимальная ширина

    max-width: максимальная ширина

    min-height: минимальная высота

    max-height: максимальная высота


Свойство box-sizing позволяет переопределить установленные размеры элементов. Оно может принимать одно из следующих значений:

    content-box: значение свойства по умолчанию, при котором браузер для определения реальных ширины и высоты элементов добавляет берет соответственно значения свойств width и height элемента
padding-box: указывает веб-браузеру, что ширина и высота элемента должны включать внутренние отступы как часть своего значения.
border-box: указывает веб-браузеру, что ширина и высота элемента должны включать внутренние отступы и границы как часть своего значения





Фон элемента описывается в CSS свойством background. Фактически это свойство представляет сокращение набора следующих свойств CSS:

    background-color: устанавливает цвет фона
background-image: в качестве фона устанавливается изображение
1
	
background-image: url(dubi.png);

Это свойство принимает одно значение: ключевое слово url, после которого в скобках идет путь к файлу изображения. В данном случае имеется в виду, что в одной папке рядом с веб-страницей находится файл dubi.png.
background-repeat: устанавливает режим повторения фонового изображения по всей поверхности элемента

background-size: устанавливает размер фонового изображения

background-position: указывает позицию фонового изображения

background-attachment: устанавливает стиль прикрепления фонового изображения к элементу

background-clip: определяет область, которая вырезается из изображения и используется в качестве фона

background-origin: устанавливает начальную позицию фонового изображения



С помощью свойства background-repeat можно изменить механизм повторения. Оно может принимать следующие значения:

    repeat-x: повторение по горизонтали

    repeat-y: повторение по вертикали

    repeat: повторение по обеим сторонам (действие по умолчанию)

    space: изображение повторяется для заполнения всей поверхности элемента, но без создания фрагментов

    round: изображение должным образом масштабируется для полного заполнения всего пространства

    no-repeat: изображение не повторяется



Свойство background-size позволяет установить размер фонового изображения. Для установки размера можно использовать либо единицы измерения, например, пиксели, либо проценты, либо одно из предустановленных значений:

    contain: масштабирует изображение по наибольшей стороне, сохраняя аспектное отношение

    cover: масштабирует изображение по наименьшей стороне, сохраняя аспектное отношение

    auto: значение по умолчанию, изображение отображается в полный размер

Если нужно масштабировать изображение таким образом, чтобы оно оптимальнее было вписано в фон, то для обеих настроек можно установить значение 100%:
1
	
background-size: 100% 100%;

Если задаются точные размеры, то вначале указывается ширина, а потом высота изображения:
1
	
background-size: 200px 150px;   /* ширина 200 пикселей, высота 150 пикселей */

Можно задать точное значение для одного измерения - ширины или высоты, а для другого задать автоматические размеры, чтобы браузер сам выводил точные значения:
1
	
background-size: 200px auto;    /* ширина 200 пикселей, автоматическая высота */


Свойство background-position управляет позицией фонового изображения внутри элемента. Оно может принимать отступы от верхнего левого угла элемента в единицах измерения, например, в пикселях 
Кроме того, данное свойство может принимать одно из следующих значений:

    top: выравнивание по верхнему краю элемента

    left: выравнивание по левому краю элемента

    right: выравнивание по правому краю элемента

    bottom: выравнивание по нижнему краю элемента

    center: изображение располагается по центру элемента


Свойство background-attachment управляет, как фоновое изображение будет прикреплено к элементу. Это свойство может принимать следующие значения:

    fixed: фон элемента фиксирован вне зависимости от прокрутки внутри элемента

    local: по мере прокрутки внутри элемента фон изменяется

    scroll: фон фиксирован и не меняется при прокрутке, но в отличие от fixed несколько элементов могут использовать свой фон, тогда как при fixed создается один фон для всех элементов


Свойство background-origin указывает позицию на изображении, с которой будет начинаться собственно фоновое изображение для элемента. Оно может принимать следующие значения:

    border-box: фон у элемента устанавливается начиная с его внешней границы, определяемой свойством border

    padding-box: фон устанавливается с учетом внутренних отступов

    content-box: фон устанавливается по содержимому элемента


Свойство background-clip определяет, какая часть изображения используется для фона. Он принимает те же значения:

    border-box: изображение обрезается по границам элемента

    padding-box: из изображения исключается та часть, которая находится под границами элемента

    content-box: изображение обрезается по содержимому с учетом внутренних отступов



Свойство box-shadow позволяет создать у элемента тень. Это свойство может принимать сразу несколько значений:


    hoffset: горизонтальное смещение тени относительно элемента. При положительном значении тень смещается вправо, а при отрицательном - влево

    voffset: вертикальное смещение тени относительно элемента. При положительном значении тень смещается вниз, а при отрицательном - вверх

    blur: необязательное значение, которое определяет радиус размытия тени. Чем больше это значение, тем более размытыми будут края тени. По умолчанию имеет значение 0.

    spread: необязательное значение, которое определяет направление тени. Положительное значение распространяет тень во вне во всех направлениях от элемента, а отрицательное значение направляет тень к элементу

    color: необязательное значение, которое устанавливает цвет тени

    inset: необязательное значение, которое заставляет рисовать тент внутри блока элемента
	
box-shadow: hoffset voffset blur spread color inset




 Контуры полезны тем, что позволяют выделить элемент, чтобы привлечь к нему внимание в какой-то ситуации. Контуры располагаются вне элемента сразу за его границами.

Контур в CSS 3 представлен свойством outline, хотя данное свойство является сокращением следующих свойств:

    outline-color: цвет контура

    outline-offset: смещение контура

    outline-style: стиль контура. Оно принимает те же значения, что и border-style:

        none: контур отсутствует

        solid: контур в виде обычной линии

        dashed: штриховая линия

        dotted: линия в виде последовательности точек

        double: контур в виде двух параллельных линий

    outline-width: толщина контура



Как правило, все блоки и элементы на веб-странице в браузере появляются в том порядке, в каком они определены в коде html. Однако CSS предоставляет специальное свойство float, которое позволяет установить обтекание элементов, благодаря чему мы можем создать более интересные и разнообразные по своему дизайну веб-страницы.

Это свойство может принимать одно из следующих значений:

    left: элемент перемещается влево, а все содержимое, которое идет ниже его, обтекает правый край элемента

    right: элемент перемещается вправо

    none: отменяет обтекание и возвращает объект в его обычную позицию

При применении свойства float для стилизуемых элементов, кроме элемента img, рекомендуется установить свойство width.

Для запрета обтекания элементов в CSS применяется свойство clear, которое указывает браузеру, что к стилизуемому элементу не должно применяться обтекание.

Свойство clear может принимать следующие значения:

    left: стилизуемый элемент может обтекать плавающий элемент справа. Слева же обтекание не работает

    right: стилизуемый элемент может обтекать плавающий элемент только слева. А справа обтекание не работает

    both: стилизуемый элемент может обтекать плавающие элементы и относительно них смещается вниз

    none: стилизуемый элемент ведет себя стандартным образом, то есть принимает участие в обтекании справа и слева


 когда содержимое блока занимает гораздо больше места, чем сам определено шириной и высотой блока. В этой ситуации по умолчанию браузер все равно отображает содержимое, даже если оно выходит за границы блока.

Однако свойство overflow позволяет настроить поведение блока в подобной ситуации и добавить возможность прокрутки. Это свойство может принимать следующие значения:

    auto: если контент выходит за границы блока, то создается прокрутка. В остальных случаях полосы прокрутки не отображаются

    hidden: отображается только видимая часть контента. Контент, который выходит за границы блока, не отображается, а полосы прокрутки не создаются

    scroll: в блоке отображаются полосы прокрутки, даже если контент весь помещается в границах блока, и таких полос прокрутки не требуется

    visible: значение по умолчанию, контент отображается, даже если он выходит за границы блока

Свойство overflow управляет полосами прокрутки как по вертикали, так и по горизонтали. С помощью дополнительных свойств overflow-x и overflow-y можно определить прокрутку соответственно по горизонтали и по вертикали. Данные свойства принимают те же значения, что и overflow




Градиенты представляют плавный переход от одного цвета к другому. В CSS3 имеется ряд встроенных градиентов, которые можно использовать для создания фона элемента.

Градиенты в CSS не представляют какого-то специального свойства. Они лишь создают значение, которое присваивается свойству background-image.

Линейный градиент распространяется по прямой от одного конца элемента к другому, осуществляя плавный переход от одного цвета к другому.

Для создания градиента нужно указать его начало и несколько цветов, например:
1
	
background-image: linear-gradient(left,black,white);
Кроме конкретных значений типа top или left также можно указать угол от 0 до 360, который определит направление градиента:
1
	
background-image: linear-gradient(30deg,black,white);

После величины углы указывается слово deg.



Для создания радиального градиента достаточно указать цвет, который будет в центре градиента, и цвет, который должен быть снаружи. Эти цвета передаются в функцию radial-gradient()
 Эллиптическая форма представляет распространение градиента в виде эллипса и задается с помощью ключевого слова ellipse
Круговая форма представляет распространение градиента в виде кругов от центра во вне. Для этого используется ключевое слово circle
Как правило, центр радиального градиента расположен в центре элемента, но это поведение можно переопределить, указав значение для параметра background-position:
1
	
background-image: radial-gradient(25% 30%, circle, white, black);

Числа 25% 30% означают, что центр градиента будет находиться на расстоянии в 25% от левой границы и в 30% от верхней границы элемента.
С помощью специальных дополнительных значений можно задать размер градиента:

    closest-side: градиент распространяется из центра только до ближайшей к центру стороне элемента. То есть градиент остается внутри элемента

    closest-corner: ширина градиента вычисляется по расстоянию из его центра до ближайшего угла элемента, поэтому градиент может выйти за пределы элемента.

    farthest-side: градиент распространяется из центра до самой дальней стороны элемента

    farthest-corner: ширина градиента вычисляется по расстоянию из его центра до самого дальнего угла элемента



Прежде всего в раскрытом состоянии к элементу details добавляется атрибут open. Соответственно, используя атрибут, можно задать разные стили для элемента в скрытом и раскрытом состоянии.
Позволяет задать стили для элемента summary в раскрытом состоянии. 
По умолчанию элемент summary в качестве маркера скрытости/раскрытости использует символ треугольника. Но его также можно настроить.

Для настройки изображения маркера можно использовать свойство list-style, а также дополнительные свойства типа list-style-type или list-style-image, которые применяются для стилизации списков.




Кроме свойства float, которое позволяет изменять позицию элемента, в CSS есть еще одно важное свойство - display. Оно позволяет управлять блоком элемента и также влиять на его позиционирование относительно соседних элементов.

Это свойство может принимать следующие значения:

inline: элемент становится строчным, подобно словам в строке текста

block: элемент становится блочным, как параграф

inline-block: элемент располагается как строка текста

list-item: элемент позиционируется как элемент списка обычно с добавление маркера виде точки или порядкового номера

run-in: тип блока элемента зависит от окружающих элементов

flex: позволяет осуществлять гибкое позиционирование элментов

table, inline-table: позволяет расположить элементы в виде таблицы

none: элемент не виден и удален из разметки html




В частности, у всех элементов по умолчанию для свойства box-sizing используется значение content-box, то есть при определении ширины и высоты элемента браузер будет прибавлять к значению свойств width и height также и внутренние отступы padding и ширину границы. В итоге это может привести к выпадению плавающих элементов из тех блоков, которые для них предназначены. Поэтому часто для всех элементов рекомендуется устанавливать для свойства box-sizing значение border-box, чтобы все элементы измерялись одинаково, а их ширина представляла только значение свойства width. Поэтому нередко в стилях добавляется следующий стиль:

1
2
3
* {
    box-sizing: border-box;




Основным свойством, которые управляют позиционированием в CSS, является свойство position. Это свойство может принимать одно из следующих значений:

static: стандартное позиционирование элемента, значение по умолчанию

absolute: элемент позиционируется относительно границ элемента-контейнера, если у того свойство position не равно static

relative: элемент позиционируется относительно его позиции по умолчанию. Как правило, основная цель относительного позиционирования заключается не в том, чтобы переместить элемент, а в том, чтобы установить новую точку привязки для абсолютного позиционированния вложенных в него элементов

fixed: элемент позиционируется относительно окна бразуера, это позволяет создать фиксированные элементы, которые не меняют положения при прокрутке

Не следует одновременно применять к элементу свойство float и любой тип позиционирования, кроме static (то есть тип по умолчанию).


Область просмотра браузера имеет верхний, нижний, правый и левый края. Для каждого из этих четырех краев есть соответствующее свойство CSS: left (отступ от края слева), right (отступ от края справа), top (отступ от края контейнера сверху) и bottom (отступ снизу). Значения этих свойств указываются в пикселях, em или процентах. Необязательно задавать значения для всех четырех сторон. Как правило, устанавливают только два значения - отступ от верхнего края top и отступ от левого края left.



По умолчанию при совпадении у двух элементов границ, поверх другого отображается тот элемент, который определен в разметке html последним. Однако свойство z-index позволяет изменить порядок следования элементов при их наложении. В качестве значения свойство принимает число. Элементы с большим значением этого свойства будут отображаться поверх элементов с меньшим значением z-index.


Для фиксированного позиционирования у элементов нужно установить значение fixed для свойства position. После этого с помощью стандартных свойств left, right, top и bottom можно определить конкретную позицию фиксированного элемента.





Для создания трансформаций в CSS3 применяется свойство transform.
Для поворота элемента свойство transform использует функцию rotate:

transform: rotate(угол_поворота deg);

Применение масштабирования имеет следующую форму:

1
transform: scale(величина_масштабирования);



Также можно по отдельности задать параметры масштабирования: функция scaleX() задает изменение по горизонтали, а scaleY() - по вертикали.



Для перемещения элемента используется функция translate:

1
transform: translate(offset_X, offset_Y);
Значение offset_X указывает, на сколько элемент смещается по горизонтали, а offset_Y - по вертикали.



С помощью дополнительных функций можно отдельно применять смещения к горизонтали или вертикали: translateX() (перемещение по горизонтали) и translateY() (перемещение по вертикали). Например:

1
transform: translateX(30px);




Для наклона элемента применяется функция skew():

1
transform: skew(X, Y);
Первый параметр указывает, на сколько градусов наклонять элемент по оси X, а второй - значение наклона по оси Y.

Для создания наклона отдельно по оси X и по оси Y в CSS есть специальные функции: skewX() и skewY() соответственно.


По умолчанию при применении трансформаций браузер в качестве точки начала преобразования использует центр элемента. Но с помощью свойства transform-origin можно изменить исходную точку. Это свойство в качестве значения принимает значения в пикселях, em и процентах. Также для установки точки можно использовать ключевые слова:

left top: левый верхний угол элемента

left bottom: левый нижний угол элемента

right top: правый верхний угол элемента

right bottom: правый нижний угол элемента



установка времени перехода в секундах с помощью свойства transition-duration





Свойства transition-timing-function позволяет контролировать скорость хода и выполнение анимации. То есть данное свойство отвечет за то, как и в какие моменты времени анимация будет ускоряться или замедляться.

В качестве значения это свойство может принимать одну из функций:

linear: линейная функция плавности, изменение свойства происходит равномерно по времени

ease: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение

ease-in: функция плавности, при которой происходит только ускорение в начале

ease-out: функция плавности, при которой происходит только ускорение в конце анимации

ease-in-out: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение

cubic-bezier: для анимации применяется кубическая функция Безье


Свойство transition-delay позволяет определить задержку перед выполнением перехода



Свойство transition представляет сокращенную запись выше рассмотренных свойств. Например, следующее описание свойств:

1
2
3
4
transition-property: background-color;
transition-duration: 3s;
transition-timing-function: ease-in-out;
transition-delay: 500ms;
Будет аналогично следующей записи:

1
transition: background-color 3s ease-in-out 500ms;




Анимация опирается на последовательню смену ключевых кадров (keyframes). Каждый ключевой кадр определяет один набор значений для анимируемых свойств. И последовательная смена таких ключевых кадров фактически будет представлять анимацию.
@keyframes название_анимации {
    from {
        /* начальные значения свойств CSS */
    }
    to {
        /* конечные значения свойств CSS */
    }
}
После ключевого слова @keyframes идет имя анимации. Затем в фигурных скобках определяются как минимум два ключевых кадра. Блок после ключевого слова from объявляется начальный ключевой кадр, а после клюевого слова to в блоке определяется конечный ключевой кадр. Внутри каждого ключевого кадра определяется одно или несколько свойств CSS, подобно тому, как создается обычный стиль.
Чтобы прикрепить анимацию к элементу, у него в стиле применяется свойство animation-name. Значение этого свойства - название применяемой анимации.

Также с помощью свойства animation-duration необходимо задать время анимации в секундах или миллисекундах. В данном случае время анимации - это 2 секунды.
В качестве значения свойства animation-name через запятую перечисляются анимации, и также через запятую у свойства animation-duration задается время этих анимаций. Название анимации и ее время сопоставляются по позиции, то есть анимация opacityAnimation будет длиться 3 секунды.

Так, свойство animation-iteration-count определяет, сколько раз будет повторяться анимация. Например, 3 повтора анимации подряд:

1
animation-iteration-count: 3;

Если необходимо, чтобы анимация запускалась бесконечное количество раз, то этому свойству присваивается значение infinite:

С помощью свойства animation-delay можно определить время задержки анимации:

Как и к переходам, к анимации можно применять все те же функции плавности:

linear: линейная функция плавности, изменение свойства происходит равномерно по времени

ease: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение

ease-in: функция плавности, при которой происходит только ускорение в начале

ease-out: функция плавности, при которой происходит только ускорение в начале

ease-in-out: функция плавности, при которой анимация ускоряется к середине и замедляется к концу, предоставляя более естественное изменение

cubic-bezier: для анимации применяется кубическая функция Безье

Для установки функции плавности применяется свойство animation-timing-function:


Свойство animation является сокращенным способом определения
Возьмем следующий набор свойств:
animation-name: backgroundColorAnimation;
animation-duration: 5s;
animation-timing-function: ease-in-out;
animation-iteration-count: 3;
animation-direction: alternate;
animation-delay: 1s;
animation-fill-mode: forwards;
Этот набор будет эквивалентен следующему определению анимации:

1
animation: backgroundColorAnimation 5s ease-in-out 3 alternate 1s forwards;


В атрибуте content мета-тега мы можем определить следующие параметры:
(в снимке экрана)
Теперь изменим предыдущий пример веб-страницу, использовав метатег:

1
2
3
4
5
6
7
8
9
10
11
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width">
        <title>Обычная веб-страница</title>
    </head>
    <body>
        <h2>Обычная веб-страница</h2>
    </body>
</html>

Используя параметр width=device-width мы говорим веб-браузеру, что в качестве начальной ширины области viewport надо считать не 980 пикселей или какое-то другое число, а непосредственную ширину экрана устройства. Поэтому затем веб-браузер не будет проводить никакого масштабирования, так как у нас ширина viewport и ширина одинаковы.



Media Query
С помощью ключевого слова and можно комбинировать условия, например:

1
<link rel="stylesheet" type="text/css" media="(min-width:481px) and (max-width:768px)" href="mobile.css" />
Данный стиль будет применяться, если ширина браузера находится в диапазоне от 481 до 768 пикселей.

С помощью директивый @import можно определить один css-файл и импортировать в него стили для определенных устройств:

1
2
3
@import url(desctop.css);
@import url(tablet.css) (min-device-width:481px) and (max-device-width:768);
@import url(mobile.css) (max-device-width:480px);


Применяемые функции в CSS3 Media Query:

aspect-ratio: отношение ширины к высоте области отображения (браузера)

device-aspect-ratio: отношение ширины к высоте экрана устройства

max-width/min-width и max-height/min-height: максимальная и минимальная ширина и высота области отображения (браузера)

max-device-width/min-device-width и max-device-height/min-device-height: максимальная и минимальная ширина и высота экрана мобильного устройства

orientation: ориентация (портретная или альбомная)


Для воспроизведения видео в HTML5 используется элемент video. Чтобы настроить данный элемент, мы можем использовать следующие его атрибуты:

src: источник видео, это может быть какой-либо видеофайл

width: ширина элемента

height: высота элемента

controls: добавляет элементы управления воспроизведением

autoplay: устанавливает автовоспроизведение

loop: задает повторение видео

muted: отключает звук по умолчанию

 <body>
        <video src="cats.mp4" width="400" height="300" controls ></video>
    </body>


Применим атрибуты autoplay и loop:

1
<video src="cats.mp4" width="400" height="300" controls autoplay loop ></video>
Теперь видео будет автоматически проигрываться бесконечное число раз.

Если при воспроизведении надо отключить звук, то мы можем воспользоваться атрибутом muted:

1
<video src="cats.mp4" width="400" height="300" controls muted ></video>
Атрибут preload

Еще один атрибут - preload призван управлять загрузкой видео. Он принимает следующие значения:

auto: видео и связанные с ним метаданные будут загружаться до того, как видео начнет воспроизводиться.

none: видео не будет загружаться в фоне, пока пользователь не нажмет на кнопку начала проигрывания

metadata: в фоне до воспроизведения будут загружаться только метаданные (данные о формате, длительности и т.д), само видео не загружается

1
<video src="cats.mp4" width="400" height="300" controls preload="auto"></video>
Атрибут poster

Атрибут poster позволяет установить изображение, которое будет отображаться до запуска видео. Этому атрибуту в качестве значения передается путь к изображению:

1
<video src="cats.mp4" width="400" height="300" controls poster="mycat.jpg"></video>

Главной проблемой при использовании элемента video является поддержка различными веб-браузерами определенных форматов. С помощью вложенных элементов source можно задать несколько источников видео, один из которых будет использоваться:

1
2
3
4
5
<video width="400" height="300" controls>
    <source src="cats.mp4" type="video/mp4">
    <source src="cats.webm" type="video/webm">
    <source src="cats.ogv" type="video/ogg">
</video>
Элемент source использует два атрибута для установки источника видео:

src: путь к видеофайлу

type: тип видео (MIME-тип)

Если браузер не поддерживает первый тип видео, то он пытается загрузить второй видеофайл. Если же и тип второго видеофайла не поддерживается, то браузер обращается к третьему видеофайлу.


Для воспроизведения звука без видео в HTML5 применяется элемент audio. Он во многом похож на элемент video. Для настройки элемента audio мы можем использовать следующие его атрибуты:

src: путь к аудиофайлу

controls: добавляет элементы управления воспроизведением

autoplay: устанавливает автовоспроизведение

loop: задает повторение аудиофайла

muted: отключает звук по умолчанию

preload: устанавливает режим загрузки файла

Действие всех этих атрибутов будет аналогично их действию в элементе video.




В JavaScript эти элементы представлены объектом HTMLMediaElement, который с помощью свойств, методов и событий позволяет управлять воспроизведением аудио и видео. Отметим наиболее важные свойства, которые могут нам пригодиться для настройки этих элементов:

playbackRate: устанавливает скорость воспроизведения. По умолчанию равно 1

src: возвращает название воспроизводимого ресурса, если он установлен в коде html элемента

duration: возвращает длительность файла в секундах

buffered: возвращает длительность той части файла, которая уже буферизирована и готова к воспроизведению

controls: устанавливает или возвращает наличие атрибута controls. Если он установлен, возвращается true, иначе возвращает false

loop: устанавливает или возвращает наличие атрибута loop. Если он установлен, возвращается true, иначе возвращает false

muted: устанавливает или возвращает наличие атрибута muted

preload: устанавливает или возвращает наличие атрибута preload

volume: устанавливает или возвращает уровень звука от 0.0 до 1.0

currentTime: возвращает текущее время воспроизведения

Отдельно для элемента video мы можем использовать ряд дополнительных свойств:

poster: устанавливает или возвращает атрибут poster

height: устанавливает или возвращает атрибут height

width: устанавливает или возвращает атрибут width

videoWidth, videoHeight: для элемента video возвращают ширину и высоту видео

Следует также отметить два метода, с помощью которых мы можем управлять воспроизведением:

play(): начинает воспроизведение

pause(): приостанавливает воспроизведение

Основные события элементов video и audio:

canplaythrough: это событие срабатывает после загрузки страницы, если браузер определит, что он может воспроизводить это видео/аудио

pause: событие срабатывает, когда воспроизведение мультимедиа приостанавливается, и оно переводится в состояние "paused"

play: событие срабатывает, когда начинается воспроизведение файла

volumechange: срабатывает при изменении уровня звука мультимедиа

ended: срабатывает при окончании воспроизведения

timeupdate: срабатывает при изменении времени воспроизведения

error: генерируется при возникновении ошибки

loadeddata: срабатывает, когда будет загружен первый фрейм видеофайла

loadedmetadata: срабатывает после загрузки метаданных мультимедиа (длительность воспроизведения, размеры видео и т.д.)

seeking: срабатывает, когда пользователь начинает перемещать курсор по шкале воспроизведения для перемещения к новому месту аудио- или видеофайла

seeked: срабатывает, когда пользователь завершил перемещение к новому месту на шкале воспроизведения








Все рисование на canvas производится с помощью кода JavaScript. Чтобы начать рисовать на canvas, нам надо получить его контекст:

1
2
var canvas = document.getElementById("myCanvas"), 
    context = canvas.getContext("2d");
Для получения контекста используется функция getContext("2d"). В данном случае мы получаем двухмерных контекст для создания двухмерной графики. Также контекст элемента canvas позволяет создавать трехмерную графику.

И наконец нам остается собственно нарисовать первую фигуру. Для рисования простейших фигур - прямоугольников нам могут понадобиться три метода:

clearRect(x, y, w, h): очищает определенную прямоугольную область, верхний левый угол которой имеет координаты x и y, ширина равна w, а высота равна h

fillRect(x, y, w, h): заливает цветом прямоугольник, верхний леый угол которого имеет координаты x и y, ширина равна w, а высота равна h

strokeRect(x, y, w, h): рисует контур прямоугольника без заливки его каким-то определенным цветом

При рисовании в функции strokeRect и fillRect передаются координаты x и y верхнего левого угла прямоугольника относительно элемента canvas, а также ширина и высота прямоугольника. При этом началом координат считается верхний левый угол элемента canvas, ось X направлена вправо, а ось Y направлена вниз

Контекст элемента canvas предоставляет ряд свойств, с помощью которых можно настроить отрисовку на canvas. К подобным свойствам относятся следующие:

strokeStyle: устанавливает цвет линий или цвет контура. По умолчанию установлен черный цвет

fillStyle: устанавливает цвет заполнения фигур. По умолчанию установлен черный цвет

lineWidth: устанавливает толщину линий. По умолчанию равно 1.0

lineJoin: устанавливает стиль соединения линий

globalAlpha: устанавливает прозрачность отрисовки на canvas

setLineDash: создает линию из коротких черточек

мы можем задать В качестве значения свойства strokeStyle и fillStyle получают название цвета в виде строки, либо в виде шестнадцатиричного значения цвета (например, "#00FFFF"), либо в виде значений rgb ("rgb(0, 0, 255)") и rgba ("rgba(0, 0, 255, 0.5)").

Свойство lineWidth позволяет установить толщину линии
 контура или границы фигур с помощью свойства strokeStyle:

Метод setLineDash() в качестве параметра принимает массив чисел, которые устанавливают расстояния между линиями. 

Свойство lineJoin отвечает за тип соединения линий в фигуре. Оно может принимать следующие значения:

miter: прямые соединения, которые образуют прямые углы. Это значение по умолчанию

round: закругленные соединения

bevel: конические соединения


Свойство globalAlpha задает прозрачность отрисовки. Оно может принимать в качестве значения число от 0 (полностью прозрачный) до 1.0 (не прозрачный)



Вместо конкретного цвета для заливки фигур, например, прямоугольников, мы можем использовать изображения. Для этого у кконтекста canvas имеется функция createPattern(), которая принимает два параметра: изображение, которое будет использоваться в качестве фона, и принцип повторения изображения. Последний параметр играет роль в том случае, если размер изображения у нас меньше, чем размер фигуры на canvas. Этот параметр может принимать следующие значения:

repeat: изображение повторяется для заполнения всего пространства фигуры

repeat-x: изображение повторяется только по горизонтали

repeat-y: изображение повторяется только по вертикали

no-repeat: изображение не повторяется

Метод createPattern() возвращает объект, который устанавливается в качестве стиля заполнения фигуры: context.fillStyle = pattern;. Отрисовка прямоугольника остается той же.




Элемент Canvas позволяет использовать градиент в качестве фона. Для этого применяется объект CanvasGradient, который можно создать либо с помощью метода createLinearGradient() (линейный градиент), либо с помощью метода createRadialGradient() (радиальный градиент).

Линейный градиент

Линейный градиент создается помощью метода createLinearGradient(x0, y0, x1, y1), где x0 и y0 - это начальные координаты градиента относительно верхнего левого угла canvas, а x1 и y1 - координаты конечной точки градиента. Например:

1
var gradient = context.createLinearGradient(50, 30, 150, 150);
Также для создания градиента необходимо задать опорчные точки, которые определяют цвет. Для этого у объекта CanvasGradient применяется метод addColorStop(offset, color), где offset - это смещение точки градиента, а color - ее цвет. Например:

1
gradient.addColorStop(0, "blue");
Смещение представляет значение в диапазоне от 0 до 1. Смещение 0 представляет начало градиента, а 1 - его конец. Цвет задается либо в виде строки, либо в виде шестнадцатиричного значения, либо в виде значения rgb/rgba.

Совпадение x-координат начальной и конечной точек создает вертикальный градиент:

1
gradient = context.createLinearGradient(50, 30, 50, 150);

А совпадение y-координат начальной и конечной точек создает горизонтальный градиент:

1
gradient = context.createLinearGradient(50, 30, 150, 30);

Радиальный градиент создается с помощью метода createRadialGradient(x0, y0, r0, x1, y1, r1), который принимает следующие параметры:

x0 и y0: координаты центра первой окружности

r0: радиус первой окружности

x1 и y1: координаты центра второй окружности

r1: радиус второй окружности

Например:

1
var gradient = context.createRadialGradient(120,100,100,120,100,30);
И также для радиального градиента нам надо задать опорные цветовые точки с помощью метода addColorStop()



Наряду с геометрическими фигурами и изображениями canvas позволяет выводить текст. Доля этого вначале надо установить у контекста canvas свойство font:

1
2
3
var canvas = document.getElementById("myCanvas"), 
    context = canvas.getContext("2d");
context.font = "22px Verdana";
Свойство font в качестве значения принимает опредление шрифта. В данном случае это шрифт Verdana высотой 22 пикселя. В качестве шрифтов используются стандартные шрифты.

Далее мы можем вывести некоторый текст с помощью метода fillText()
Метод fillText(text, x, y) принимает три параметра: выводимый текст и x и y координаты точки, с которой выводится текст.

Для вывода текста можно также применять метод strokeText()

Свойство textAlign позволяет выровнить текст относительно одной из сторон. Это свойство может принимать следующие значения:

left: текст начинается с указанной позиции

right: текст завершается до указанной позиции

center: текст располагается по центру относительно указанной позиции

start: значение по умолчанию, текст начинается с указанной позиции

end: текст завершается до указанной позиции
Свойство lineWidth задает ширину линии текста

Свойство textBaseline задает выравнивание текста по базовой линии. Оно может принимать следующие значения:

top

middle

bottom

alphabetic

hanging

ideographic

С помощью метода measureText() можно определить ширину текста на canvase






Flex-элементы во flex-контейнере могут иметь определенное направление, а именно они могут располагаться в виде строк или в виде столбцов. Для управления направлением элементов CSS3 предоставляет свойство flex-direction. Оно определяет направление элементов и может принимать следующие значения:

row: значение по умолчанию, при котором элементы располагаются в виде строки слева направо

row-reverse: элементы также располагаются в виде стоки только в обратном порядке справа налево

column: элементы располагаются в столбик сверху вниз

column-reverse: элементы располагаются в столбик в обратном порядке снизу вверх


Свойство flex-wrap определяет, будет ли flex-контейнер несколько рядов элементов (строк или столбцов) в случае если его размеры недостаточны, чтобы вместить в один ряд все элементы. Это свойство может принимать следующие значения:

nowrap: значение по умолчанию, которое определяет flex-контейнер, где все элементы раполагаются в одну строку (при расположении в виде строк) или один столбец (при расположении в столбик)

wrap: если элементы не помещаются во flex-контейнер, то создает дополнительные ряды в контейнере для размещения элементов. При расположении в виде строки содаются дополнительные строки, а при расположении в виде столбца добавляются дополнительные столбцы

wrap-reverse: то же самое, что и значение wrap, только элементы располагаются в обратном порядке



Свойство align-items также выравнивает элементы, но уже по поперечной оси (cross axis) (при расположении в виде строки по вертикали, при расположении в виде столбца - по горизонтали). Это свойство может принимать следующие значения:

stretch: значение по умолчанию, при котором flex-элементы растягиваются по всей высоте (при расположении в строку) или по всей ширине (при расположении в столбик) flex-контейнера

flex-start: элементы выравниваются по верхнему краю (при расположении в строку) или по левому краю (при расположении в столбик) flex-контейнера

flex-end: элементы выравниваются по нижнему краю (при расположении в строку) или по правому краю (при расположении в столбик) flex-контейнера

center: элементы выравниваются по центру flex-контейнера

baseline: элементы выравниваются в соответствии со своей базовой линией


Свойство align-self позволяет переопределить значение свойства align-items для одного элемента. Оно может принимать все те же значения плюс значение "auto":

auto: значение по умолчанию, при котором элемент получает значение от свойства align-items, которое определено в flex-контейнере. Если в контейнере такой стиль не определен, то применяется значение stretch.

stretch

flex-start

flex-end

center

baseline


Свойство align-content управляет выравниванием рядов (строк и столбцов) во flex-контейнере и поэтому применяется, если свойство flex-wrap имеет значение wrap или wrap-reverse. Свойство align-content может иметь следующие значения:

stretch: значение по умолчанию, при котором строки (столбцы) растягиваются, занимая все свободное место

flex-start: строки (столбцы) выравниваются по началу контейнера (для строк - это верхний край, для столбцов - это левый край контейнера)

flex-end: строки (столбцы) выравниваются по концу контейнера (строки - по нижнему краю, столбцы - по правому краю)

center: строки (столбцы) позиционируются по центру контейнера

space-between: строки (столбцы) равномерно распределяются по контейнеру, а между ними образуются одинаковые отступы. Если же имеющегося в контейнере места недостаточно, то действует аналогично значению flex-start

space-around: строки (столбцы) равным образом распределяют пространство контейнера, а растояние между первой и последней строкой (столбцом) и границами контейнера составляет половину расстояния между соседними строками (столбцами).

Стоит учитывать, что это свойство имеет смысл, если в контейнере две и больше строки (столбца).



Кроме свойств, устанавливающих выравнивание элементов относительно границ flex-контейнера, есть еще три свойства, которые позволяют управлять элементами:

flex-basis: определяет начальный размер flex-элемента

flex-shrink: определяет, как flex-элемент будет уменьшаться относительно других flex-элементов во flex-контейнере

flex-grow: определяет, как flex-элемент будет увеличиваться относительно других flex-элементов во flex-контейнере



Свойство flex-basis определяет начальный размер flex-элемента до того, как он начнет изменять размер, подстраиваясь под размеры flex-контейнера.

Это свойство может принимать следующие значения:

auto: начальный размер flex-элемента устанавливается автоматически

content: размер flex-элемента определяется по его содержимому, в то же время это значение поддерживается не всеми современными браузерами, поэтому его пока стоит избегать

числовое значение: мы можем установить конкретное числовое значение для размеров элемента



Свойство flex является объединением свойств flex-basis, flex-shrink и flex-grow и имеет следующий формальный синтаксис:

1
flex: [flex-grow] [flex-shrink] [flex-basis]
По умолчанию свойство flex имеет значение 0 1 auto.

Кроме конкретных значений для каждого из подсвойств мы можем задать для свойства flex одно из трех общих значений:

flex: none: эквивалентно значению 0 0 auto, при котором flex-элемент не растягивается и не усекается при увеличении и уменьшении контейнера

flex: auto: эквивалентно значению 1 1 auto

flex: initial: эквивалентно значению 0 1 auto





















при ширине от 600px и выше для заполнения всего пространства браузера у body устанавливается стиль height: 100vh;.

Элементы header и footer аналогичны. Их свойство flex: 0 0 5em; указывают, что при любом изменении контейнера эти элементы будут иметь размер в 5em. То есть они имеют статический размер.

Более сложным является элемент main, который определяет основное содержимое. При этом будучи flex-элементом, он также является flex-контейнером для вложенных элементов и управляет их позиционированием. При ширине браузера до 600px он располагает элементы в столбик, что очень удобно на мобильных устройствах.

При ширине от 600px вложенные элементы nav, article и aside располагаются в виде строки. И поскольку при такой ширине браузера родительский элемент body заполняет по высоте все пространство браузера, то для заполнения всей высоты контейнера body при его изменении у элемента main устанавливается свойство flex: 1 1 auto;.

У вложенных в main flex-элементов стоит отметить, что элемент навигации nav и элемент сайдбара aside будут иметь одинаковые размеры при масштабировании контейнера. А элемент article, содержащий основное содержимое, будет соответственно больше. При этом хотя nav определен после элемента article, но благодаря установке свойства order: -1 блок навигации будет стоять до блока article.





Основой для определения компоновки Grid Layout является grid container, внутри которого размещаются элементы. Для создания grid-контейнера необходимо присвоить его стилевому свойству display одно из двух значений: grid или inline-grid.
Если значение grid определяет контейнер как блочный элемент, то значение inline-grid определяет элемент как строчный (inline)
Грид образует сетку из строк и столбцов, на пересечении которых образуются ячейки. И для установки строк и столбцов в Grid Layout использовать следующие свойства CSS3:

grid-template-columns: настраивает столбцы

grid-template-rows: настраивает строки

Столбцы

Для определения столбцов используем у grid-контейнера стилевое свойство grid-template-columns.
В качестве значения свойству grid-template-columns передается ширина столбцов. Сколько мы хотим иметь в гриде столбцов, столько и нужно передать значений этому свойству. Так, в случае выше грид содержит два столбца, поэтому свойству передаются два значения, которые указывают ширину столбцов
Соответственно если мы хотим, чтобы в гриде было три столбца, то нам надо передать три значения, например:

1
grid-template-columns: 8em 7em 8em;

Настойка строк во многом аналогичная настройке столбцов. Для этого у грид-контейнера необходимо установить свойство grid-template-rows, которое задает количество и размеры строк
Свойству grid-template-rows передается высота каждой из строк.
Если у нас столбцов и(или) строк много и они имеют одинаковые размеры, то есть смыл использовать специальную функцию repeat(), которая позволит настроить строки и столбцы. Так, в примере выше повторяется определение одинаковых строк и столбцов в grid-контейнере:

1
2
grid-template-columns: 8em 8em 8em;
grid-template-rows: 5em 5em 5em 5em;

Свойство grid объединяет свойства grid-template-rows и grid-template-columns и разом позволяет задать настройки для строк и столбцов в следующем формате:

1
grid: grid-template-rows / grid-template-columns;
Для создания отступов между столбцами и строками применяются свойства grid-column-gap и grid-row-gap соответственно.
Если значения свойств grid-column-gap и grid-row-gap совпадают, то вместо них можно определить одно свойство gap (ранее назвалось grid-gap), которое установит оба отступа

grid-row-start: задает начальную горизонтальную grid-линию, с которой начинается элемент

grid-row-end: указывает, до какой горизонтальной grid-линии надо растягивать элемент

grid-column-start: задает начальную вертикальную grid-линию, от которой начинается элемент

grid-column-end: указывает, до какой вертикальной grid-линии нужно растягивать элемент

С помощью специального слова span можно задать растяжение элемента на несколько ячеек. После слова span указывается, на какое количество ячеек надо растянуть элемент:

По умолчанию все элементы располагаются по порядку горизонтально, если места в строке больше нет, то элементы переносятся на следующую строку. Но с помощью свойства grid-auto-flow можно изменить направление элементов. Это свойство принимает два значения:

row: значение по умолчанию, элементы располагаются в строку друг за другом, если места в строке не хватает, элементы переносятся на следующую строку

column: элементы располагаются в столбик, если места в столбце не хватает, то элементы переходят в следующий столбец
Свойство order позволяет задать порядок элементов. По умолчанию для каждого элемента в гриде это свойство имеет значение 0. Поэтому элементы располагаются друг за другом как они определены в разметке html. 